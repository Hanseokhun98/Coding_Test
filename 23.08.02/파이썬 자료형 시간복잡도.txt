* 리스트 : 가장 많이 사용, 몇몇 연산의 경우는 매우 느리기 때문에 코딩테스트에 사용 시에는 주의해야함

-------------------------------------------------------
     연산        |  평균 시간 복잡도  |  최악 시간 복잡도 
-------------------------------------------------------
     복사        |       O(n)        |       O(n)      
-------------------------------------------------------
    append       |       O(1)        |       O(1)      
-------------------------------------------------------
    pop(-1)      |       O(1)        |       O(1)      
-------------------------------------------------------
    pop(n)       |       O(n)        |       O(n)      
-------------------------------------------------------
 첫번째 원소 삽입 |       O(n)        |       O(n)      
-------------------------------------------------------
    원소 삭제    |       O(n)        |       O(n)      
-------------------------------------------------------
     extend      |       O(n)        |       O(n)      
-------------------------------------------------------
     정렬        |    O(nlog n)      |    O(nlog n)      
-------------------------------------------------------
    x in s       |       O(n)        |             
-------------------------------------------------------
 min(s), max(s)  |       O(n)        |             
-------------------------------------------------------
     len(s)      |       O(1)        |       O(1)       
-------------------------------------------------------

* 딕셔너리 : 어떤 원소가 키(key)에 포함되어 있는지를 검사할 때 거의 대부분의 경우, 이 연산은 O(1) 복잡도를 갖는다는점
            최악의 경우는 발생하는 경우가 정말 희박하기 때문에, 코딩테스트에서 어떤 값이 자료형에 포함되었는지를 
            검사하는 경우는 딕셔너리를 사용하는 것이 리스트보다 훨씬 유리

-------------------------------------------------------
     연산        |  평균 시간 복잡도  |  최악 시간 복잡도 
-------------------------------------------------------
    k in d       |       O(1)        |       O(n)      
-------------------------------------------------------
     복사        |       O(n)        |       O(n)      
-------------------------------------------------------
   값 꺼내기      |       O(1)        |       O(n)       ->
-------------------------------------------------------
  값 업데이트     |       O(1)        |       O(n)       ->  해시 충돌 때문, 서로 다른 키가 동일한 해시 값을 가지는 상황
-------------------------------------------------------
    값 삭제       |       O(1)        |       O(n)       ->
-------------------------------------------------------

* 셋 : 리스트와 유사한 자료형이지만, 원소가 중복되지 않는다는 점이 다름
       셋은 해시 테이블을 사용하여 구현되어 있기 때문에, 키가 몇 개인지와 상관없이 삽입, 삭제, 검색 연산이 모두 O(1) 복잡도를 가짐

---------------------------------------------------------------------
          연산          |     평균 시간 복잡도      |  최악 시간 복잡도 
---------------------------------------------------------------------
         x in s         |          O(1)            |       O(n)      
---------------------------------------------------------------------
        합집합 s         |           1             | O(len(s)*len(1))      
---------------------------------------------------------------------
       교집합 s&t        |   O(min(len(s),len(t))) | O(len(s)*len(1))      
---------------------------------------------------------------------
       차집합 s-t        |        O(len(s))         |           
---------------------------------------------------------------------
 s.difference_update(t) |        O(len(1))         |                  -> 집합 t 와 차집합(s-t)을 구하고, 집합 s 갱신
---------------------------------------------------------------------
